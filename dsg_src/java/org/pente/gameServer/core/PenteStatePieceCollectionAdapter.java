/**
 * PenteStatePieceCollectionAdapter.java
 * Copyright (C) 2001 Dweebo's Stone Games (http://www.pente.org/)
 * <p>
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 * <p>
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * <p>
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you can find it online at
 * http://www.gnu.org/copyleft/gpl.txt
 */

package org.pente.gameServer.core;

import java.util.*;
import java.awt.*;

import org.pente.game.*;

public class PenteStatePieceCollectionAdapter extends SimplePenteState {

    protected Vector listeners;
    protected Vector gridPieces;

    public PenteStatePieceCollectionAdapter() {
        this(19, 19);
    }

    /** Create an empty pente state wrapped around the given GridState
     *  @param gridState The base GridState to use
     */
    public PenteStatePieceCollectionAdapter(GridState gridState) {
        super(gridState);

        listeners = new Vector();
        gridPieces = new Vector();
    }

    /** Create a pente state with a certain board size
     *  @param boardSize The board size
     */
    public PenteStatePieceCollectionAdapter(int boardSizeX, int boardSizeY) {
        super(boardSizeX, boardSizeY);

        listeners = new Vector();
        gridPieces = new Vector();
    }


    public void addOrderedPieceCollectionListener(OrderedPieceCollection pieceCollection) {
        listeners.addElement(pieceCollection);
    }

    public void removePieceCollectionListener(OrderedPieceCollection pieceCollection) {
        listeners.removeElement(pieceCollection);
    }

    /** Clears the grid state */
    public void clear() {
        super.clear();
        gridPieces.removeAllElements();
        for (int i = 0; i < listeners.size(); i++) {
            OrderedPieceCollection o = (OrderedPieceCollection) listeners.elementAt(i);
            o.clearPieces();
        }
    }

    /** Add a move for this board
     *  @param move An integer representation of a move
     */
    public void addMove(int move) {

        // add grid piece
        GridPiece p = new SimpleGridPiece();
        p.setPlayer(super.getCurrentColor());
        p.setDepth(super.getNumMoves() + 1);
        int x = move % super.getGridSizeX();
        int y = super.getGridSizeY() - move / super.getGridSizeX() - 1;
        p.setX(x);
        p.setY(y);

        super.addMove(move);

        GridPieceAction a = new GridPieceAction(p, super.getNumMoves(), GridPieceAction.ADD);
        gridPieces.addElement(a);

        for (int i = 0; i < listeners.size(); i++) {
            OrderedPieceCollection o = (OrderedPieceCollection) listeners.elementAt(i);
            o.addPiece(p, super.getNumMoves());
        }
    }

    //added for puzzle applet
    public void setPosition(int position, int value) {
        super.setPosition(position, value);

        GridPiece p = new SimpleGridPiece();
        p.setPlayer(value);
        p.setDepth(1);//doesn't matter hopefully
        int x = position % super.getGridSizeX();
        int y = super.getGridSizeY() - position / super.getGridSizeX() - 1;
        p.setX(x);
        p.setY(y);

        GridPieceAction a = new GridPieceAction(p, super.getNumMoves(), GridPieceAction.ADD);
        gridPieces.addElement(a);
    }

    /** Undo the last move */
    public void undoMove() {

        for (int i = 0; i < gridPieces.size(); i++) {
            GridPieceAction a = (GridPieceAction) gridPieces.elementAt(i);
            if (a.getTurn() == super.getNumMoves()) {
                gridPieces.removeElementAt(i);
            }
        }

        super.undoMove();

        for (int i = 0; i < listeners.size(); i++) {
            OrderedPieceCollection o = (OrderedPieceCollection) listeners.elementAt(i);
            o.undoLastTurn();
        }
    }

    // overridden
    protected void captureMove(int move, int capturePlayer) {
        super.captureMove(move, capturePlayer);

        Coord p = convertMove(move);
        int x = p.x;
        int y = p.y;
        y = super.getGridSizeY() - y - 1;

        for (int i = gridPieces.size() - 1; i >= 0; i--) {
            GridPieceAction a = (GridPieceAction) gridPieces.elementAt(i);
            if (a.getGridPiece().getX() == x &&
                    a.getGridPiece().getY() == y) {

                for (int j = 0; j < listeners.size(); j++) {
                    OrderedPieceCollection o = (OrderedPieceCollection) listeners.elementAt(j);
                    o.removePiece(a.getGridPiece(), super.getNumMoves());
                }

                break;
            }
        }
    }
}