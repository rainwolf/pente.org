package org.pente.tree;

import java.io.*;

import org.pente.game.Coord;
import org.pente.game.HashCalculator;
import org.pente.game.GridState;
import org.pente.game.MoveData;
import org.pente.game.PenteState;

import org.pente.game.ZobristUtil;

//import org.apache.log4j.*;

public class FastPenteStateZobrist implements PenteState {

//    private static final Category log4j = Category.getInstance(
//        FastPenteStateZobrist.class.getName());
    
    private static int surrounding[] = new int[] {
        -20, -19, -18, -1, 20, 19, 18, 1
    };
    
    private int board[] = new int[362];
    private int moves[] = new int[362];
    private int numMoves = 0;
    private int currentPlayer = 1;
    private boolean gameOver = false;
    
    private int captures[] = new int[3];
    private int capturedAt[][] = new int[3][40];
    private int capturedMoves[][] = new int[3][40];

    // hash stuff
    private long hashes[][] = new long[362][9];
    private int rots[] = new int[362];

    private int size;
    private int max;
    private int half;
    public void setSize(int size) {
    	this.size = size;
    	surrounding = new int[] {
    	    -size - 1, -size, -size + 1, -1, size + 1, size, size - 1, 1
    	};
    	max = size * size;
    	half = size / 2;
    }
    
    public int getGridSizeX() {
        return size;
    }

    public int getGridSizeY() {
        return size;
    }

    public int getCurrentColor() {
        return currentPlayer;
    }

    public int getColor(int moveNum) {
    	return currentPlayer;
    }
    public int getCurrentPlayer() {
        return currentPlayer;
    }

    public void addMove(int move) {
        moves[numMoves++] = move;
        board[move] = currentPlayer;
        currentPlayer = 3 - currentPlayer;
        capture();
        checkGameOver();
        updateHash(null);
    }


    public void undoMove() {
        board[moves[--numMoves]] = 0;
        
        for (int i = 0; i < 8; i++) {
            hashes[numMoves][i] = 0;
        }
        hashes[numMoves][8] = 0;
        
        currentPlayer = 3 - currentPlayer;
        undoCapture();
        gameOver = false;
    }

    public void capture() {
        int move = moves[numMoves - 1];
        int p = board[move];
        int op = 3 - p;
        for (int i = 0; i < 8; i++) {
            int c1 = move + surrounding[i];
            int c2 = c1 + surrounding[i];
            int c3 = c2 + surrounding[i];
            if (!isValidPosition(c3, move)) continue;
            int pos1 = board[c1];
            int pos2 = board[c2];
            int pos3 = board[c3];
            if (pos1 == op && pos2 == op && pos3 == p) {
                capturedAt[p][captures[p]] = numMoves - 1;
                capturedMoves[p][captures[p]] = c1;
                captures[p]++;
                capturedAt[p][captures[p]] = numMoves - 1;
                capturedMoves[p][captures[p]] = c2;
                captures[p]++;
                board[c1] = 0;
                board[c2] = 0;
            }
        }
    }
    public void undoCapture() {
        int p = currentPlayer;
        int op = 3 - p;
        while (captures[p] > 0 &&
               capturedAt[p][captures[p] - 1] == numMoves) {

            int move = capturedMoves[p][captures[p] - 1];
            board[move] = op;

            capturedAt[p][captures[p] - 1] = 0;
            capturedMoves[p][captures[p] - 1] = 0;
            captures[p]--;
        }
    }
     
    public void checkGameOver() {
        if (captures[1] > 9 || captures[2] > 9) {
            gameOver = true;
            return;
        }

        int origMove = moves[numMoves - 1];
        int move = 0;
        int p = board[origMove];
        int op = 3 - p;
        int lines[] = new int[4];
        for (int i = 0; i < 8; i++) {
            move = origMove;
            for (int j = 0; j < 4; j++) {
                int newMove = move + surrounding[i];
                if (!isValidPosition(newMove, move)) break;
                move = newMove;
                if (board[move] != p) break;
                lines[i % 4]++;
            }
        }
        for (int i = 0; i < 4; i++) {
            if (lines[i] >= 4) {
                gameOver = true;
                break;
            }
        }
    }
    
    public int getMove(int num) {
        return moves[num];
    }

    public int getNumMoves() {
        return numMoves;
    }

    public int getPosition(int position) {
        //if (position < 0 || position > 361) return 0;
        return board[position];
    }

    public void setPosition(int position, int value) {
        board[position] = value;
    }
    
    
    public boolean isGameOver() {
        return gameOver;
    }

    public void clear() {
        numMoves = 0;
        for (int i = 0; i < 362; i++) {
            board[i] = 0;
        }
        captures[1] = 0;
        captures[2] = 0;
        for (int i = 1; i < 3; i++) {
            for (int j = 0; j < 40; j++) {
                capturedAt[i][j] = 0;
                capturedMoves[i][j] = 0;
            }
        }
    }


    
    
    
    public int getNumCaptures(int player) {
        return captures[player];
    }


    public boolean isValidPosition(int newPosition, int oldPosition) {
        // if passes over top or bottom
        if (newPosition < 0 || newPosition > max - 1) return false;
        
        int oldX = oldPosition % size;
        int newX = newPosition % size;
        int diffX = oldX - newX;
        // if passes over side
        if (diffX > half + 1 || diffX < -half + 1) {
            return false;
        }
        return true;
    }



    // hashing...
    public long getHash() {
        return hashes[numMoves - 1][8];
    }
    public int getRotation() {
        return rots[numMoves - 1];
    }

    public long getHash(int index) {
        return hashes[index][8];
    }
    public int getRotation(int index) {
        return rots[index];
    }
    
    static final int rotx[] = new int[] { 1, 1,  1,  1, -1, -1, -1, -1 };
    static final int roty[] = new int[] { 1, 1, -1, -1, -1, -1,  1,  1 };
    static final int rotf[] = new int[] { 0, 1,  0,  1,  0,  1,  0,  1 };

    public int rotateMove(int move, int rotationIndex) {
        int x = move % size;
        int y = move / size;
        int x1 = (x - half) * rotx[rotationIndex];
        int y1 = (y - half) * roty[rotationIndex];
        if (rotf[rotationIndex] != 0) {
            int t = x1;
            x1 = y1;
            y1 = t;
        }
        return (y1 + half) * size + x1 + half;
    }

    public int[] getAllPossibleRotations(int move, int newRotation) {
    	return null;//not used
    }
    public int rotateMoveToLocalRotation(int move, int newRotation) {
        return rotateMoveToLocalRotation(move, newRotation, numMoves - 1);
    }
    public int rotateMoveToLocalRotation(int move, int newRotation, int moveNum) {
        int x = move % size;
        int y = move / size;

        int x1 = (x - half) * rotx[newRotation];
        int y1 = (y - half) * roty[newRotation];
        if (rotf[newRotation] != 0) {
            int t = x1;
            x1 = y1;
            y1 = t;
        }

        x = -1;
        y = -1;

        newRotation = rots[moveNum];
        int x2 = x1;
        int y2 = y1;
        if (rotf[newRotation] != 0) {
            int t = x2;
            x2 = y2;
            y2 = t;
        }
        x2 = x2 * rotx[newRotation] + half;
        y2 = y2 * roty[newRotation] + half;

        if (x2 > x || x2 == x && y2 > y) {
            x = x2;
            y = y2;
        }

        return y * size + x;
    }

    public void updateHash(HashCalculator calc) {

        if (numMoves == 0) {
            return;
        }
        else if (numMoves == 1) {
            for (int i = 0; i < 8; i++) {
                hashes[0][i]=0;
            }
        }
        else if (numMoves > 1) {
            // copy prev. moves hashes into current moves
            for (int i = 0; i < 8; i++) {
                hashes[numMoves - 1][i] = hashes[numMoves - 2][i];
            }
        }
            
        // record hash, rotation of move
        long maxHash = Long.MIN_VALUE;
        int maxRotation = 0;
        int move = moves[numMoves - 1];
        int p = board[move];
        int op = 3 - p;
        
        // for each possible rotation of this move
        for (int j = 0; j < 8; j++) {
            // XOR with hash for the new move
            hashes[numMoves - 1][j] ^= ZobristUtil.rand[p-1][rotateMove(move, j)];

            // if was a capture, XOR out hash for captured pieces
            for (int i = 0; i < capturedAt[p].length; i++) {
                if (capturedAt[p][i] == 0){
                    break;
                }
                else if (capturedAt[p][i] == numMoves - 1) {
                    int capMove = rotateMove(capturedMoves[p][i], j);
                    hashes[numMoves - 1][j] ^= ZobristUtil.rand[op-1][capMove];
                }
            }
            
            // now XOR in number captures for each player
            if (captures[1] > 0) {
                hashes[numMoves - 1][j] ^= ZobristUtil.rand[2][captures[1]]; 
            }
            if (captures[2] > 0) {
                hashes[numMoves - 1][j] ^= ZobristUtil.rand[3][captures[2]];
            }
            
            // record max hash and which rotation it occurred on
            if (hashes[numMoves - 1][j] > maxHash) {
                maxHash = hashes[numMoves - 1][j];
                maxRotation = j;
            }
        }
        
        // store max rotation and max hash
        rots[numMoves - 1] = maxRotation;
        hashes[numMoves - 1][8] = maxHash;
    }
 

    public static void main(String args[]) throws IOException {
        
        // tests simple mirroring
        FastPenteStateZobrist s1 = new FastPenteStateZobrist();
        s1.addMove(180);
        s1.addMove(181);
        s1.addMove(182);
        s1.addMove(183);
        
        FastPenteStateZobrist s2 = new FastPenteStateZobrist();
        s2.addMove(180);
        s2.addMove(237);
        s2.addMove(218);
        s2.addMove(199);
        
        System.out.println(s1.positionEquals(s2));
        
        for (int i = 0; i < 4; i++) {
            long h1 = s1.getHash(i);
            long h2 = s2.getHash(i);
            System.out.println(i + " " + (h1 == h2) + " " + h1 + "," + h2);
        }
        
        // this one tests 2 positions that have the same moves
        // but include captured pieces from different locations
        // the end hash is the same, indicating that the removal off
        // captured piece data from the hash is working
        s1.clear();
        s2.clear();
        s1.addMove(180);
        s1.addMove(181);
        s1.addMove(123);
        s1.addMove(182);
        s1.addMove(183);
        s1.addMove(182);
        s1.addMove(199);
        
        s2.addMove(180);
        s2.addMove(182);
        s2.addMove(183);
        s2.addMove(142);
        s2.addMove(199);
        s2.addMove(161);
        s2.addMove(123);

        System.out.println(s1.positionEquals(s2));
        
        for (int i = 0; i < 7; i++) {
            long h1 = s1.getHash(i);
            long h2 = s2.getHash(i);
            System.out.println(i + " " + (h1 == h2) + " " + h1 + "," + h2);
        }
    }
    public boolean positionEquals(GridState s) {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }
//
//        FastPenteStateZobrist
//        if (numMoves != fstate.getNumMoves()) {
//            return false;
//        }
//        if (captures[1] != fstate.getNumCaptures(1) ||
//            captures[2] != fstate.getNumCaptures(2)) {
//            return false;
//        }
//
//        // rotate moves from passed in state to the same rotation as this
//        // state, add them to a new fastpentestate
//        FastPenteStateZobrist rotated = new FastPenteStateZobrist();
//        rotated.addMove(180);
//        for (int i = 1; i < numMoves; i++) {
//            int rotMove = rotateMoveToLocalRotation(fstate.getMove(i),
//                fstate.getRotation());
//            rotated.addMove(rotMove);
//            
//            //System.out.print(moves[i] + ":" + gridState.getMove(i) + ":" + rotMove + 
//            //    ":" + rots[i] + ":" + gridState.getRotation(i) + " ");
//        }
//        //System.out.println();
//        
//        // then check that the boards are equal (in cases same boards created
//        // from a different sequence of moves)
//        for (int i = 0; i < 361; i++) {
//            if (board[i] != rotated.board[i]) {
//                return false;
//            }
//        }
//
//        return true;
//    }
    
    // unsupported, shouldn't be needed for ai stuff
    public int getWinner() {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }
    public int[] getMoves() {
        int m[]=new int[numMoves];
        for (int i = 0; i < numMoves; i++) {
            m[i]=moves[i];
        }
        return m;
    }
    
    public boolean isValidMove(int move, int player) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

 
    public boolean canPlayerUndo(int player) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }


    public int[][] getBoard() {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }


    
    public int getPosition(int x, int y) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

    public void setPosition(int x, int y, int value) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

    public int convertMove(int x, int y) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

    public Coord convertMove(int move) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }




    public GridState getInstance(MoveData moveData) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

    public void setTournamentRule(boolean rule) {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");

    }


    public int[] getCaptures(int atMove) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }
    public void setCaptureLengths(int[] lengths) {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");

    }


    public void setCapturesToWin(int num) {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }

    public void setGPenteRules(boolean gpente) {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }

    public void setDPenteRules(boolean dpente) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }
    
    public boolean didDPenteSwap() {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }
    public void dPenteSwapDecisionMade(boolean swap) {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }

    public boolean wasDPenteSwapDecisionMade() {
        throw new UnsupportedOperationException(
            "Not supported in fast pente state.");
    }
    
    public long[][] getHashes() {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }
    public int[] getRotations() {
        throw new UnsupportedOperationException(
        "Not supported in fast pente state.");
    }
    public void setInitCaptures(int player, int caps) {

    }
    public void printBoard() {}
}
