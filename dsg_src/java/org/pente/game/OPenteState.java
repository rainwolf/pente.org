package org.pente.game;

public class OPenteState extends SimplePoofPenteState {

    public OPenteState(GridState gridState) {
        super(gridState);
        init();
    }

    public OPenteState() {
        super();
        init();
    }

    public OPenteState(
            MoveData data,
            int boardSizeX,
            int boardSizeY) {

        super(data, boardSizeX, boardSizeY);
        init();
    }

    public OPenteState(int boardSizeX, int boardSizeY) {
        super(boardSizeX, boardSizeY);
        init();
    }

    public void init() {
        super.init();

        poofedAt = new int[3][40];
        poofedMoves = new int[3][40];

        setTournamentRule(true);
        setGPenteRules(false);
    }

    private static final int surrounding[] = new int[] { -1, 1, -20, 20, -19, 19, -18, 18 };
    private int winner = 0;

    public boolean isGameOver() {

        // else check for 5 in a row that is capture proof
        int maxMove = gridState.getGridSizeX() * gridState.getGridSizeY() - 1;

        moves: for (int m = 0; m < getNumMoves(); m++) {
            int p = m % 2 + 1;
            int op = 3 - p;
            int moves[][] = new int[4][9]; // store the found connected stones in each direction, 4 on each side, + the move itself.
            int c[] = new int[4]; // count the number of connected stones per direction
            cs: for (int i = 0; i < surrounding.length; i++) {
                // each i is a direction, so 4 directions

                int newMove = getMove(m); // start afresh with the m-th move

                // make sure move is still there
                if (getPosition(newMove) != p) {
                    continue moves;
                }
                else if (c[i/2] == 0){
                    moves[i/2][c[i/2]++] = newMove;
                }

                for (int j = 0; j < gridState.getGridSizeX(); j++) {

                    int oldX = newMove % gridState.getGridSizeX();
                    newMove += surrounding[i];
                    int newX = newMove % gridState.getGridSizeX();

                    // if passes over side
                    if ((oldX == 0 && newX == gridState.getGridSizeX() - 1) ||
                            (oldX == gridState.getGridSizeX() - 1 && newX == 0)) {
                        continue cs;
                    }

                    if (newMove < 0 || newMove > maxMove) {
                        continue cs;
                    }

                    if (getPosition(newMove) != p) {
                        continue cs;
                    }
                    moves[i/2][c[i/2]++] = newMove;
                }
            }

            checkPosCaps: for (int i = 0; i < 4; i++) {
                if (c[i] >= 5) { // if there's a pente in any direction

                    // if the current move was white and black still has a win
                    // then that means black wins (even if white makes a 5 also this turn)
                    // otherwise continue checking all moves, if in the end
                    // white wins with black having no counter-moves, then white wins
                    if (p == getCurrentPlayer()) {
                        winner = p;
                        return true;
                    }

                    for (int j = 0; j < c[i]; j++) {
                        int move = moves[i][j];
                        for (int k = 0; k < 8; k++) { // in all directions, check for captures of 2 stones, won't work for keryo
                            int c1 = moves[i][j] + surrounding[k];
                            int c2 = c1 + surrounding[k];
                            int c3 = moves[i][j] - surrounding[k];
                            if (!isValidPosition(c1, move)) continue; // if ci and move are not on opposite edges of the board
                            if (!isValidPosition(c2, move)) continue; // or if ci doesn't go off the top or bottom of the board
                            if (!isValidPosition(c3, move)) continue;

                            int pos1 = getPosition(c1);
                            int pos2 = getPosition(c2);
                            int pos3 = getPosition(c3);
                            if ((pos1 == p && pos2 == op && pos3 == 0) ||
                                    (pos1 == p && pos2 == 0 && pos3 == op)) {
                                System.out.println("found pot. cap");
                                continue checkPosCaps;
                            }
                        }
                    }
                    for (int j = 0; j < c[i]; j++) {
                        int move = moves[i][j];
                        for (int k = 0; k < 8; k++) { // in all directions, check for captures of 3 stones, where the middle is not in the 5
                            int c1 = moves[i][j] + surrounding[k];
                            int c2 = c1 + surrounding[k];
                            int c3 = c2 + surrounding[k];
                            int c4 = moves[i][j] - surrounding[k];
                            if (!isValidPosition(c1, move)) continue; // if ci and move are not on opposite edges of the board
                            if (!isValidPosition(c2, move)) continue; // or if ci doesn't go off the top or bottom of the board
                            if (!isValidPosition(c3, move)) continue;
                            if (!isValidPosition(c4, move)) continue;

                            int pos1 = getPosition(c1);
                            int pos2 = getPosition(c2);
                            int pos3 = getPosition(c3);
                            int pos4 = getPosition(c4);
                            if ((pos1 == p && pos2 == p && pos4 == op && pos3 == 0) ||
                                    (pos1 == p && pos2 == p && pos4 == 0 && pos3 == op)) {
                                System.out.println("found pot. 3 cap");
                                continue checkPosCaps;
                            }
                        }
                    }
                    for (int j = 0; j < c[i]; j++) {
                        int move = moves[i][j];
                        for (int k = 0; k < 8; k++) { // in all directions, check for captures of 3 stones, where the middle is in the 5
                            int c1 = moves[i][j] + surrounding[k];
                            int c2 = moves[i][j] - surrounding[k];
                            int c3 = c2 - surrounding[k];
                            int c4 = c1 + surrounding[k];
                            if (!isValidPosition(c1, move)) continue; // if ci and move are not on opposite edges of the board
                            if (!isValidPosition(c2, move)) continue; // or if ci doesn't go off the top or bottom of the board
                            if (!isValidPosition(c3, move)) continue;
                            if (!isValidPosition(c4, move)) continue;

                            int pos1 = getPosition(c1);
                            int pos2 = getPosition(c2);
                            int pos3 = getPosition(c3);
                            int pos4 = getPosition(c4);
                            if ((pos1 == p && pos2 == p && pos4 == op && pos3 == 0) ||
                                    (pos1 == p && pos2 == p && pos4 == 0 && pos3 == op)) {
                                System.out.println("found pot. 3 cap");
                                continue checkPosCaps;
                            }
                            k++; // only 4 directions matter
                        }
                    }
                    winner = p;

                }
            }
        }

        if (winner != 0) {
            return true;
        }

        // check win on captures
        // must be greater than capturesToWin and greater than the opponents
        // captures.  so if the game is 10-10, play continues until one player
        // gets another capture or 5 in a row
        if (captures[1] != captures[2]) {
            if (captures[1] >= capturesToWin) {
                winner = 1;
                return true;
            }
            else if (captures[2] >= capturesToWin) {
                winner = 2;
                return true;
            }
        }

//        int lastMove = getMove(getNumMoves() - 1);
//        // if the move made was captured
//        if (getPosition(lastMove) == 0) {
//            // since move made was poofed, we can't have won with 5 in a row
//            // since the board is the same as before
//            return false;
//        }



        return false;
    }

    /** Overridden because it is possible for the player who just played to
     *  lose if they play into a poof which brings the capture count to 10 or
     *  above.
     */
    public int getWinner() {
        if (isGameOver()) {
            return winner;
        }
        else {
            return 0;
        }
    }

    public void addMove(int move) {

        gridState.addMove(move);

        for (int i = 0; i < captureLengths.length; i++) {
            makeCaptures(captureLengths[i]);
        }
        updateHash(this);
    }



    void makeCaptures(int captureLength) {

        int tempCaptured[] = new int[24]; // 24 is max?
        int numCaptured = 0;
        int tempPoofed[] = new int[12]; // 12 is max (actually 9 is but this
        // part of the code doesn't remove dups
        int numPoofed = 0;

        int lastPosition = getMove(getNumMoves() - 1);

        // normal capture routine except store captures temporarily
        for (int i = 0; i < surrounding.length; i++) {
            int capturedMoves[] = new int[captureLength];
            if (capture(capturedMoves, lastPosition, surrounding[i])) {
                for (int j = 0; j < captureLength; j++) {
                    tempCaptured[numCaptured++] = capturedMoves[j];
                }
            }
        }

        // go all the way around the last move and attempt to capture from that
        // position towards the last move
        for (int i = 0; i < surrounding.length; i++) {
            int newPosition = lastPosition + surrounding[i];
            if (isValidPosition(newPosition, lastPosition)) {
                int poofedMoves[] = new int[captureLength];
                if (capture(poofedMoves, newPosition, surrounding[i] * -1)) {
                    for (int j = 0; j < poofedMoves.length; j++) {
                        tempPoofed[numPoofed++] = poofedMoves[j];
                    }
                }
            }
        }

        for (int i = 0; i < numCaptured; i++) {
            captureMove(tempCaptured[i], getPosition(lastPosition));
        }
        for (int i = 0; i < numPoofed; i++) {
            poofMove(tempPoofed[i]);
        }
    }

    public GridState getInstance(MoveData moveData) {
        SimpleGomokuState gomoku = new SimpleGomokuState(
                gridState.getGridSizeX(), gridState.getGridSizeY());
        gomoku.allowOverlines(true);
        OPenteState oPentestate = new OPenteState(gomoku);
        oPentestate.setCaptureLengths(captureLengths);
        oPentestate.setCapturesToWin(capturesToWin);
        oPentestate.setGPenteRules(gPenteRules);
        oPentestate.setTournamentRule(tournamentRule);

        for (int i = 0; i < moveData.getNumMoves(); i++) {
            oPentestate.addMove(moveData.getMove(i));
        }

        return oPentestate;
    }

    
}
